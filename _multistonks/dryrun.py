#this one should simply look at the getList list generated by an algo, and display the date added and % change since adding (essentially the same as what stonk2 was doing with fda)
#syntax for running should be "python3 dryrun.py {algo2test selected from algosDir}"

#TODO: there are errors that cause the stocks to seem like they're delisted when they're not. Possibly only check during week days? Also make sure that there's a valid response rather than nothing to confirm that it was actually delisted
#TODO: add % over threshold output (ie how many have reached a certain gain % or loss %). Maybe also add avg return %?

import otherfxns as o
import sys,json,time,os
import datetime as dt
from colorama import init as colorinit

colorinit() #allow coloring in Windows terminals

#change display text color
class bcolor:
    HEADER = '\033[95m'
    OKBLUE = '\033[94m'
    OKCYAN = '\033[96m'
    OKGREEN = '\033[92m'
    WARNING = '\033[93m'
    FAIL = '\033[91m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'

cfgFile = './configs/dryrun.config'
c = o.configparser.ConfigParser()
c.read(cfgFile)

sys.path.append(c['file locations']['stockAlgosDir'])

if(len(sys.argv)>1): #if there's an argument present
  if(len(sys.argv)<3):
    algo = sys.argv[1].lower()
  else:
    raise ValueError("Too many arguments. Please specify only one algo to test")
else: #no argument present
  raise ValueError("No argument present. Please specify the algo to test")

exec(f"import {algo}")
exec(f"{algo}.init('{cfgFile}')")

while True:
  todayList = eval(f"{algo}.getList()") #get today's list
  
  #get the cumulative list history (contains "purchase" date, symb, note, maxGain, maxLoss)
  if(os.path.isfile(c['file locations']['purchLists']+algo+".json")): #if file exists
    purchList = json.loads(open(c['file locations']['purchLists']+algo+".json",'r').read()) #read from the file
  else: #file doesn't exist
    purchList = {} #init with nothing
  #append today onto the cumulative and save to file
  for e in todayList: # for all the new ones
    d = e #set the base name
    i=0 #set the base appending number
    #only append a number to the name if the symbol is already present and the purchDate was before today
    while d in purchList and purchList[d]['purchDate']<str(dt.date.today()):
      i += 1 #increment
      d = e+"-"+str(i) #append number - #TODO: this might be not used? follow the logic about what's happening with it
    purchList[d] = { #store data
      "purchDate":str(dt.date.today()),
      "buyPrice":0,
      "note":todayList[e],
      "high":1,
      "highDate":str(dt.date.today()),
      "low":1,
      "lowDate":str(dt.date.today())
    }
  
  # print(*[e.split("-")[0] for e in purchList],sep="\n")
  prices = o.getPrices([e.split("-")[0]+"|stocks" for e in purchList]) #get prices for all stocks in the list
  prices = {s.split("|")[0]:prices[s]['price'] for s in prices} #isolate to {symb:price}
  
  #this way we only have to call getPrices once
  #go through all recorded ones (including today's), skip the ones already initiated, keep the ones present and in the price range, and remove the rest
  for e in list(purchList):
    if(purchList[e]['buyPrice']==0):
      if(e in prices):
        purchList[e]['buyPrice'] = prices[e]
      else:
        purchList.pop(e)
  
  print("symb\tcurrent\tbuyDate\t\thigh\thighDate\tlow\tlowDate\t\ttriggers\tnote")
  print("----\t-------\t----------\t-----\t----------\t-----\t----------\t-----------\t----------")
  for e in purchList:
    if(e in prices):
      if(prices[e]/purchList[e]['buyPrice']>purchList[e]['high']): #if the change is the new highest, record it
        purchList[e]['high'] = round(prices[e]/purchList[e]['buyPrice'],2)
        purchList[e]['highDate'] = str(dt.date.today())
      elif(prices[e]/purchList[e]['buyPrice']<purchList[e]['low']): #if the change is the new lowest, record it
        purchList[e]['low'] = round(prices[e]/purchList[e]['buyPrice'],2)
        purchList[e]['lowDate'] = str(dt.date.today())
    else: #it's not in the prices
      if("delisted" not in purchList[e]['note'].lower()):
        purchList[e]['note'] += ", possibly delisted"
      
    sellUp = eval(f"{algo}.sellUp('{e}')")
    sellDn = eval(f"{algo}.sellDn('{e}')")
    #display the list
    print((f"{e}\t"
          f"{bcolor.OKGREEN if e in prices and prices[e]/purchList[e]['buyPrice']>=1 else bcolor.FAIL}{round(prices[e]/purchList[e]['buyPrice'],2) if e in prices else 0}{bcolor.ENDC}\t"
          f"{purchList[e]['purchDate']}\t"
          f"{bcolor.FAIL if purchList[e]['high']<1 else bcolor.OKGREEN}{purchList[e]['high']}{bcolor.ENDC}\t"
          f"{purchList[e]['highDate']}\t"
          f"{bcolor.FAIL if purchList[e]['low']<1 else bcolor.OKGREEN}{purchList[e]['low']}{bcolor.ENDC}\t"
          f"{purchList[e]['lowDate']}\t"
          f"{sellDn} & {sellUp}\t"
          f"{purchList[e]['note']}"))
  
  if(len(purchList)>0):
    winners = [e for e in purchList if purchList[e]['high']>=sellUp and (purchList[e]['highDate']<purchList[e]['lowDate'] or purchList[e]['low']>=sellDn)]
    losers = [e for e in purchList if purchList[e]['low']<sellDn and (purchList[e]['lowDate']<purchList[e]['highDate'] or purchList[e]['high']<sellUp)]
    #TODO: add avg win and loss values
    percWon = len(winners)/len(purchList)
    percLost = len(losers)/len(purchList)
  else:
    [percWon,percLost] = [0,0]
  print(f"won:\t{round(100*percWon,2)}%")
  print(f"lost:\t{round(100*percLost,2)}%")
  
  open(c['file locations']['purchLists']+algo+".json",'w').write(json.dumps(purchList)) #save to the file
  print(f'testing algo "{algo}"')
  
  timeBeforeClose = 30 #check 30 seconds before close to ensure it's open
  ttc = o.timeTillClose()
  if(ttc<timeBeforeClose):
    time.sleep(timeBeforeClose+5) #wait till after market closes
  time.sleep(o.timeTillClose()-timeBeforeClose) #wait till the next close
  